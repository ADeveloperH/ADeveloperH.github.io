---
layout: post
title: Kotlin（一）
categories: Kotlin相关
---

### 参考资料 ###

[Kotlin官网](https://www.kotlincn.net/docs/reference/)   

[Kotlin In Action 中文版GitBook](https://panxl6.gitbooks.io/kotlin-in-action-in-chinese/content/introduction.html)   

[Kotlin 语言参考文档中文版](http://www.liying-cn.net/kotlin/docs/kotlin-docs.pdf)   

[kotlin 的干货搜集 ，不能错过](http://kotlin.cn/?/article/6)   


### 环境搭建 ###

使用 IDEA 开发：

[Kotlin Primer·第一章·启程](https://kymjs.com/code/2017/02/03/01/)   


### 1 Kotlin 基础语法 ###

#### 1.1 变量声明、函数声明 ####

```java 
package chapter1

/**
 * 变量名在前，变量类型在后，如果类型能推断可以不用写类型
 */

//var 表示变量
var age: Int = 28

//val 表示不可变的变量。注意：不是常量
val name: String = "huangjian"

//如果类型可以推断出来，可以不用写类型
var sex = "male"


var str1: String = "test"
//String 和 String? 是两种不同的类型。是不能互相赋值的
//String 类型是不可为空的，如果设置为空编译器会报错
//String? 是可以为空也可以不为空的类型
var str2: String? = "test2"

fun main(args: Array<String>) {
    //不能直接赋值，因为是两种不同的类型，如果能保证 str2 不为空，可以加  !! 进行强转赋值
    str1 = str2!!

    //可以直接赋值，因为 String? 表示可以为空和不可为空的类型，其中包含 String
    str2 = str1

    //入参不能是 String? 类型
//    pringLn(str2)

    pringLn(str1)
}


/**
 * 函数以关键字 fun 标识
 * 1、函数参数声明和变量声明一致
 * 2、函数返回值在函数体后声明
 */
fun pringLn(arg: String): String {
    //Kotlin 的模板语法：可以使用 $ 在字符串中引用变量
    println("字符串为：$arg")
    return arg
}



```

#### 1.2 Kotlin 和 Java 互调  ####

Idea 定义 Java 代码生成 main 函数模板：  
[intellij idea优化_生成main方法_自动补全代码_live template](https://blog.csdn.net/cwy52/article/details/52184965)   


```java

JavaMain.java 文件

package chapter1.class2;

public class JavaMain {

    //测试与 Kotlin 关键字冲突问题
    public static String in = "in";

    public static void main(String[] args){
        //调用 Kotlin 中的函数，直接通过 “文件名Kt.方法名”调用
        //Util 中声明的方法、变量 ，最终都会被编译成 public
        UtilKt.echo(UtilKt.getName());

        //调用匿名内部类
        Test.INSTANCE.sayMsg("hello from main");

    }
}


Util.kt 文件

package chapter1.class2

import kotlin.reflect.KClass

//最终被编译成 public 变量
var name = "huangjian"

/**
 * Kotlin 的函数直接可以写在文件中，不用写在类中
 * 最终被编译成 public 的方法，在 Java 类中可以直接通过文件名调用该方法
 */
fun echo(name: String) {
    println("$name")
}

fun main(args: Array<String>) {
    //Kotlin 中可以直接调用匿名类的方法
    Test.sayMsg("hello from Kotlin")
}

/**
 * 匿名内部类的写法
 */
object Test {
    fun sayMsg(msg: String) {
        println(msg)

        //java 的 class 对象传入方式
        testClass(JavaMain::class.java)

        //kotlin 的 class 对象传入方式
        testClass(KotlinMain::class)

        //kotlin 掉 Java 变量，变量名与 kotlin 的关键字冲突时使用 ``
        println(JavaMain.`in`)
    }
}

/**
 * 测试入参为 Java 的 Class
 */
fun testClass(clazz: Class<JavaMain>) {
    println(clazz.simpleName)
}

/**
 * 测试入参为 Kotlin 的 Class。Kotlin 的 Class 为 KClass
 */
fun testClass(clazz: KClass<KotlinMain>) {
    println(clazz.simpleName)
}

KotlinMain.kt 文件

package chapter1.class2

class KotlinMain


```

#### 1.3 Kotlin 与 Java 的不同  ####

Kotlin 没有封装类，所有的变量最终都被解释为 Java 中的基本数据类型，而不是封装类型

```java

TestInterface.java 文件

package chapter1.class3;

public interface TestInterface {
    //入参为基本数据类型
    void putNumber(int number);

    //入参为封装类型
    void putNumber(Integer number);
}

Test.java 文件

package chapter1.class3;

public class Test implements TestInterface {
    @Override
    public void putNumber(int number) {
        System.out.println("int 类型的调用");
    }

    @Override
    public void putNumber(Integer number) {
        System.out.println("Integer 类型的调用");
    }
}

Test.kt 文件

package chapter1.class3

fun main(args: Array<String>) {
    //调用 Java 中 Test 类的方法，调用的是入参为 int 类型的方法，不是入参为 Integer 的方法
    //如果想要调用 入参为 Integer 类型的方法，需要使用反射才能调用
    Test().putNumber(123)//输出为“int 类型的调用”
}


class TestInKotlin : TestInterface {
    override fun putNumber(number: Int) {
    }

    //编译器会提示没有 Integer 这个类型的
//    override fun putNumber(number: Int?) {
//    }

}

```

Kotlin 类型没有空值敏感

```java

Test.java 文件

package chapter1.class3;

public class Test{
    //声明静态方法
    public static String fromat(String string) {
        return string.isEmpty() ? null : string;
    }
}


Test.kt 文件

package chapter1.class3

fun main(args: Array<String>) {
    function("")
}

fun function(str: String) {
    //编译器类型推断为 String! ，这个类型是编译器临时使用的，不能手动的声明
    val fmat1 = Test.fromat(str)
    //会报错，因为范围值为 null 不是 String 类型
//    val fmat2: String = Test.fromat(str)
    val fmat3: String? = Test.fromat(str)

    //会报空指针错误，因为 fmat1 可能为 null
//    println(fmat1.length)

    //Kotlin 的特性，空安全
    println(fmat3?.length)//输出为 null
}

```

Kotlin 没有静态变量和静态方法，声明静态方法和静态变量的方法如下：

```java

Test.kt 文件

package chapter1.class3

object KotlinTest {
    //使用 @JvmStatic 注解，将 Kotlin 中方法声明为静态变量
    @JvmStatic
    val str: String = "str from KotlinTest "

    //使用 @JvmStatic 注解，将 Kotlin 中方法声明为静态方法，在 Java 可以直接通过“类名.方法名”调用
    @JvmStatic
    fun print(str: String) {
        println(str)
    }
}


Test.java 文件

package chapter1.class3;

public class Test {
    public static void main(String[] args) {
        //调用 Kotlin 中的静态方法和静态变量
        KotlinTest.print(KotlinTest.getStr());
    }
}


```

#### 1.4 Kotlin 中的函数 ####

函数和方法的区别(Java 中只有方法，没有函数)： 

[方法（method）和函数（function）有什么区别？](http://blog.jobbole.com/44230/)   

[函数和方法的区别](https://blog.csdn.net/qq_34952846/article/details/78943800)   



```java

Kotlin.kt 文件

package chapter1.class4

fun echo(name: String) {
    println("$name")
}

/**
 * 带默认值的函数，可大大减少方法重载的数量
 */
fun echo2(name: String = "huangjian") {
    println(name)
}

/**
 * 函数体只有一个语句时，可以直接赋值给函数
 */
fun echo3(name: String) = println("$name")


/**
 * 函数嵌套。不建议使用
 * 递归调用时，或者不希望函数被外部访问时可以使用内部函数
 */
fun function() {
    val str = "hello world"
    fun say(count: Int = 10) {
        println(str + count)
        if (count > 1) {
            say(count - 1)
        }
    }
    say()
}

fun main(args: Array<String>) {
    echo("hello")
    echo2()
    echo2("hello2")
    echo3("hello3")

    function()
}

```

Kotlin 中的扩展函数，用于一些第三方的 SDK，或者不可更改的类中新增方法时，如下：

```java

Test.kt 文件

package chapter1.class5

import java.io.File
import java.nio.charset.Charset

/**
 * Kotlin 独特的扩展函数
 * 静态的给类添加成员变量和成员方法
 */
fun File.readText(charset: Charset = Charsets.UTF_8): String = readBytes().toString(charset)

fun main(args: Array<String>) {
    val file = File("KotlinIDEA.iml")
    println(file.readText())
}

JavaMain.java 文件

package chapter1.class5;

import kotlin.text.Charsets;
import java.io.File;

public class JavaMain {
    public static void main(String[] args){
        File file = new File("KotlinIDEA.iml");

        //Java 中调用 Kotlin 中的扩展函数，注意需要将扩展的对象作为第一个入参传入，而且没有默认的入参值
        String result = TestKt.readText(file, Charsets.UTF_8);
        System.out.println(result);
    }
}


```

Kotlin 扩展函数静态解析，没有运行时多态

```java

Test.kt 文件

package chapter1.class5


/**
 * Kotlin 中的类默认加上 final 关键字
 * open 表示这个类不是 final 的
 */
open class Animal

class Dog : Animal()

//给 Animal 新增静态方法
fun Animal.name() = "animal"
//给 Dog 新增静态方法
fun Dog.name() = "dog"

//给 Animal 新增静态方法
fun Animal.printName(animal: Animal) {
    println(animal.name())
}
//给 Dog 新增静态方法
fun Dog.printName2(animal: Animal) {
    println(animal.name())
}
//给 Dog 新增静态方法
fun Dog.printName3(dog: Dog) {
    println(dog.name())
}

fun main(args: Array<String>) {
    /**
     * 扩展函数静态解析，没有运行时多态
     */
    Dog().printName(Dog())//输出“animal”
    Dog().printName2(Dog())//输出“animal”
    Dog().printName3(Dog())//输出“dog”
}

```